# [TIL] JS_함수

<br />

### 함수

<br />

![Untitled-1](https://user-images.githubusercontent.com/81572770/148593177-d873fe8f-5a59-4066-aa56-f45241de8218.png)

- 일련의 과정을 문으로 구현하고 코드블록으로 감싸서, 하나의 실행 단위로 정의한 것
  - 매개변수 : 함수 외부의 값을 함수 내부로 전달 받을 수 있는 변수
  - 인수 : 함수 호출할 때 입력 받는 값  

→ 즉, 함수가 호출될 때 인수(입력값)가 매개변수라는 전달 통로를 통해 함수 내부로 들어가고 함수가 실행된 후, 해당 결과값이 출력된다.

<br />

```javascript
function getSum(num1, num2){
  return num1 + num2;
}

console.log(getSum(10,20));  // 30 출력
```
→ 함수를 호출(실행)시키면 매개변수자리에 10과 20을 받아서 getSum함수에서 연산한 뒤,  
  함수가 호출되고 있는 자리가 return으로 값으로 대체면서 console창에 연산된 값이 출력되는 것이다.

<br />
<br />

### 함수 리터럴
- 함수도 객체타입의 값이기 때문에, function키워드 / 함수명 / 매개변수 / 함수 몸체으로 구성된 함수 리터럴로 표기한다.  
  (단, 함수는 객체지만 일반객체와는 달리 함수는 호출할 수 있다!)
- 함수 리터럴은 표현식으로 함수 이름이 있는 **기명함수**와 함수 이름이 없는  **익명함수**가 있다.
- 함수 이름은 함수 몸체내에서만 참조할 수 있는 식별자이다!!  
  (함수 몸체 **외부에서는 함수이름으로 함수를 호출할 수 없다.**)
- 함수 리터럴은 **변수에 할당할 수 있다**...! (함수 선언문과 혼동하지 말기!)
- 피연산자로 사용할 수 있다.

<br />
<br />

## 함수 정의 4가지

### 1. 함수 선언문
- 표현식이 아닌 문이기 때문에, **변수에 할당할 수 없다!!**
- 이름이 있는 함수로, 반드시 함수 이름을 갖고 있어야 한다! (생략 불가능)
  → 이름 생략 시, syntaxError (문법 에러) 발생
- 피연산자로도 사용할 수 없다!

- 함수이름으로 함수 외부에서 함수를 참조할 수 없으나, **자바스크립트 엔진에 의해**  
  **암묵적으로 함수이름과 동일한 이름의 식별자를 생성**해 함수 선언문을 호출할 수 있도록 만든다.  
  → 즉, 함수 이름이 아닌 함수 객체를 가리키는 식별자로 호출함!
- 함수 호이스팅이 발생한다.

<br />

```javascript
// 함수 선언문
function abc(x,y) {
  return x * y;
}

console.log(abc(5,3));
```
<br />

***[문제] 다음은 함수 리터럴 표현식일까..? 아니면 함수 선언문일까..?***

```javascript
let foo = function foo() {
  console.log('나는야, foo함수');
}

foo();    // 나는야, foo함수
```
→ 답: `기명함수 리터럴 표현식`  
  
  분명 함수 이름이 존재하기 때문에 당연히 함수 선언문이라고 생각할 수 있지만,  
  함수 선언문은 변수에 할당할 수 없기 때문에 위의 문제는 `함수 리터럴 표현식`이다!

  `함수 선언문`과 `이름이 있는 함수 리터럴표현식`은 둘 다 함수명이 있기 때문에   
  똑같아 보이는데, 자바스크립트는 어떻게 이 2개를 구분할까?

  → 자바스크립트 엔진은  **함수이름이 있는 함수가 단독으로 사용**되었으면 `함수 선언문`으로 해석하고, **함수 이름이 있는데 변수에 할당되거나 피연산자로 사용된 경우**에 `함수 리터럴 표현식`으로 해석한다!
  (참고로 함수 선언문과 함수리터럴은 함수를 호출할 때 차이점이 있다.)

<br />

즉, 기명함수 리터럴은 함수 선언문 또는 함수 리터럴표현식 둘 다 해석될 수 있고  
해당 함수가 어떻게 사용되었는지에 따라 자바스크립트 엔진의 해석이 달라지는 것이다!!

<br />

### 2. 함수 표현식
- 함수를 변수에 대입해서 선언하는 방식
  → 함수를 직접 호출할 수 없기 때문에 변수에 대입해서 호출한다.
- 대부분 익명함수 형태로 사용
- 함수 호이스팅이 발생하지 않는다!

<br />

```javascript
// 함수 표현식
const abc = function (x,y) {
  return x * y;
}

console.log(abc(5,3));    // 15
```

<br />

### 3. Function 생성자 함수

<br />

### 4. 화살표 함수 (ES6)
- function 키워드 대신, `=>` 를 이용해서 함수를 선언해주는 것이다.

```javascript
const sum = (a, b) => a + b;
```

<br />
<br />

## 함수 호이스팅
- 함수 선언문이 코드의 최상단으로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유 특징  

원래 자바스크립트는 코드가 순차적으로 해석되기 때문에   
함수가 선언되기 전에 함수 호출이 먼저 작성되어 있다면, 에러가 발생해야 한다.  

하지만 함수 선언문이 정의되면 **함수 호이스팅으로 인해 런타임 이전에 함수객체가 먼저 생성되면서**  
함수 선언문이 가장 먼저 동작될 수 있도록 끌어 올려지면서, 정상적으로 값을 반환할 수 있게 만든다.

<br />

> 💚 변수 호이스팅과 함수 호이스팅의 차이
>   
> 변수와 함수 둘다 자바스크립트 엔진에 의해 런타임(동작)이전에 먼저 실행되어 식별자를 생성하지만,   
> 선언된 변수는 값에 undefined를 담아서 초기화하고  
> 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화 한다. 

<br />
<br />

## 다양한 함수 형태

<br />

### 즉시 실행 함수

<br />
<br />

### 재귀함수

<br />
<br />

### 중첩함수

<br />
<br />

### 콜백함수

<br />
<br />

### 순수함수
- 외부 상태에 의존하지 않고, 변경하지도 않는 함수
- 오직 **매개변수를 통해 함수 내부로 전달된 인수에게만 의존**하여 return값을 만들기 때문에    
  동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수이다.   

<br />

***[예제1-1] 순수함수***

```javascript
var count = 0;

function increase(n){
  return ++n;
}

increase(count);
console.log(count);    // 0

increase(count);
console.log(count);    // 0
```
→ increase함수를 호출할 때 변수 count의 값을 인수로 넣었다.    
  변수 count의 값이 increase함수의 매개변수 통로를 통해 함수내부로 들어가고   

  .... 질문하기! (왜 1이 아닌 0이 출력될까....)

  참고로 순수함수로서, 외부상태를 변경하지 않는 특징이 있다.   
  그래서 increase함수가 호출될 때 **반환된 결과값을 다시 count라는 변수에 재할당 하지 않으면**  
  전달되는 인수(count)의 값은 전역에서 계속 0으로 존재하고 있어 계속   

<br />

***[예제1-2] 예제1-1번 순수함수의 값이 상태변경될 수 있도록 처리***

```javascript
var count = 0;

function increase(n){
  return ++n;
}

count = increase(count);
console.log(count);      // 1

count = increase(count);
console.log(count);     // 2
```
→ 맨처음 count = 0 으로 할당된 값을 매개변수로 넣어서 결과값 을 반환했고   
  반환된 1 값을 다시 count변수에 재할당 시켜 increase함수의 인수로 넣었다.   

  맨처음엔 0이라는 값이 들어갔지만 이제 1이라는 값이 재할당되어 들어갔기 때문에   
  결과값은 2가 반환된다!


<br />
<br />

### 비순수함수
- 외부 상태에 의존하여 외부 상태를 변경하는 함수

<br />

***[예제1] 비순수함수***

```javascript
var count = 0;

function increase(){
  return ++count;
}

increase();
console.log(count);  // 1

increase();
console.log(count);   // 2
```
→ 인수로 전달 받지 않고 전역변수 count가 함수 내에서 직접 참조되어 값의 상태가 변경되고 있으므로,    
  count는 계속 1씩 증가되어 출력된다.

<br />
<br />