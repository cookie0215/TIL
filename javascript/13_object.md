# [TIL] JS_객체
자바스크립트는 **객체 기반**의 프로그래밍 언어이다.
원시타입을 제외한 나머지 값(함수, 배열, 정규표현식...등)은 모두 객체로 구성되어 있다!

<br />

## 💚원시타입과 객체타입   
  
### 원시타입   
- 단하나의 값만 나타냄, 변경 불가능한 값을 의미 (불변성)  
  → 한번 생성된 값(데이터)은 읽기 전용만 가능하고, 해당 변수에 다른 값을 재할당할 순 있다!  
  → 즉, 변수의 메모리 공간에 값(데이터)이 할당된 후, 다른 값으로 재할당할 때   
    기존의 값이 있던 자리에 새로운 값이 들어오는 것이 아니라!!    
    변수(메모리 공간)의 주소가 변경되는 것이다!

- 변수에 원시 값을 할당 시, **변수(메모리 공간)에 실제 값이 저장**됨!  
  → 원시값을 할당한 변수를 또다른 변수에 할당하면 원본의 원시 값이 복사 되어 전달됨  
  이것을 '**값에 의한 전달**'이라 한다.  
  (사실, 엄격하게 따지면 값 자체를 전달하는 것이 아니라 메모리 공간 자체를 복사해서 전달한다고 봐야 하는데...  
  이건 또 2가지 관점으로 바라보는 듯 하다..ㅠㅠ)

<br />

***[예제1] 변수 a값을 복사해서 변수 b에 전달한 뒤, 변수 a값을 변경해보기***

```javascript
let a = 10;
let b = a;    //(참고로 깊은 복사가 발생함)

console.log(a);    // 10
console.log(b);    // 10
console.log(a === b)    // true  

a = 30;

console.log(a);    // 30
console.log(b);    // 10
console.log(a === b)    // false

```

→ 변수 b에 변수 a값 자체를 복사해서 전달했기 때문에 당연히 b에는 10이 할당된다.  
하지만 변수 a값이 30으로 바뀌었다고 해서 변수 b의 값도 30으로 변하는 것은 아니다!  
왜냐하면 변수 a의 메모리 주소를 복사해서 전달받았더라도 a와 b 서로 다른 메모리 공간을 갖고 있기 때문에 서로 간섭할 수 없다.   
그래서 b는 그대로 10이 출력된다!!

<br />


<br />
<br />

### 객체타입  
- 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조,  변경 가능한 값을 의미
- 변수에 객체 값을 할당 시, **변수(메모리 공간)에 참조값이 저장**됨!  
  → 객체를 할당한 변수를 또다른 변수에 할당하면 원본의 참조 값이 복사 되어 전달됨
  이것을 '**참조에 의한 전달**'이라 한다.  
  (즉, 변수가 재할당하지 않고 객체를 직접 변경한다!)

  *참조값은  객체가 저장된 메모리 공간의 주소라고 볼 수 있다.*  

- 객체는 참조에 의한 전달이기 때문에 원본 객체와 복사된 객체의 메모리 주소는 다르더라도 동일한 참조 값을 갖기 때문에  
서로의 프로퍼티에 영향을 미친다!!   
  → 즉, 원본객체가 새로 만든 객체에게 참조값을 복사해 할당한 뒤,   
  원본 객체의 key값이 변경되었을 때 새로 만든 객체의 key값도 동일하게 변경되는 것을 볼 수 있다!!

<br />

<br />

***[예제2] 객체를 할당한 변수를 다른 변수에 할당하기***

```javascript
const obj1 = { x: 10 };
const obj2 = obj1;

console.log(obj1);   // { x: 10 }
console.log(obj2);   // { x: 10 }
console.log(obj1 === obj2);   // true

obj1.x = 30;
console.log(obj1);   // {x: 30}
console.log(obj2);   // {x: 30}
console.log(obj1 === obj2);   // true

```
→ 원본 객체(obj1)가 새로운 객체(obj2)에게 값을 복사해서 할당하고, 원본 객체(obj1)가 프로퍼티 x의 key값을 30으로 변경한 것을 볼 수 있다.

  여기서 만약 **원시 값**이였다면 기존의 변수가 새로운 변수에 값을 할당하고 기존의 변수 값을 재할당했을 때,  
  새로운 변수값은 기존의 값에게 전달 받았던 그대로 존재하고 기존의 변수 혼자만 쏙 변경되는 것을 볼 수 있을 텐데   

  obj1, obj2는 객체로써 참조값을 전달하기 때문에 obj1의 key값이 변경됐을 때,  
  obj2의 key값도 똑같이 30으로 변경되는 것을 볼 수 있다!! 

<br />
<br />

## 객체 형태

<br />

![Untitled-1](https://user-images.githubusercontent.com/81572770/148565047-b061e49a-ed6d-4876-ae9d-ae1e966fd084.png)

<br />

- 객체는 **0개 이상의 프로퍼티로 구성된 집합**이고,  
- 프로퍼티는 key(속성) 과 value(값)으로 구성되어 있다.  
  
  > key는 보통 **camelCase**형태로 작성한다.  
  > key를 **중복 선언**하면 **나중에 선언된 프로퍼티**가 처음 선언된 프로퍼티를 덮어쓴다! 

- 여러개의 프로퍼티를 나열할 때 `,` 쉼표로구분
- 프로퍼티의 값은 배열, 문자열, 객체, 함수... 등 모든 값으로 전달 받을 수 있다.  

  (만약 **프로퍼티값을 함수로 전달 받게 되면 그 값을 메소드**라고 한다!!)


> 정리
>
> 프로퍼티 : 객체의 상태를 나타내는 값(데이터)  
> 메서드 : 프로퍼티를 참조하고 조작할 수 있는 동작

<br />
<br />

## 자바스크립트 객체 생성 방법
- 객체 리터럴  
  : `{}` 중괄호 안에 0개 이상의 프로퍼티를 작성하는 방법  
  
    *🖐 리터럴 : 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법*

    ```javascript
      let obj = {
        fruit1: 'apple',
        fruit2: 'mango'
      }
    ```

- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

<br />
<br />

## 프로퍼티 접근 및 삭제

1. `.` 마침표를 사용해서 프로퍼티key에 접근
2. `[]` 대괄호를 사용해서 프로퍼티key에 접근  
  : `[]`대괄호를 사용할 때는 반드시, key를 `''` 따옴표로 감싼 문자열 형태로 작성해야 한다!

<br />

```javascript
let user = {
  name: 'kim'
}

console.log(user.name);
console.log(user['name']);
```

<br />

- 존재하지 않은 프로퍼티에 접근 시, 에러가 아닌 **undefined를 반환**한다!

- 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가, 할당된다!

```javascript
let user = {
  name: 'kim'
}

console.log(user.age);   // undefined

user.age = 20;
console.log(user.age);   // 20

```

<br />

- 이미 존재하는 프로퍼티 값을 재할당할 수 있다.

```javascript
let user = {
  name: 'kim'
}

user.name = 'park';
console.log(user.name);   // park
```

<br />

- 프로퍼티를 삭제하려면 **delete**연산자를 사용한다.

```javascript
let user = {
  name: 'kim',
  age: 20
}

delete user.name;
console.log(user);   // {age: 20}
```

<br />
<br />

## 객체 리터럴 확장 기능 (ES6)

### 축약 표현
- 프로퍼티 값을 변수에 할당된 값(식별자 표현식)으로 넣을 수 있다.
- 프로퍼티 값을 변수로 사용할 때, key와 변수로 사용된 값이 똑같다면  
  축약해서 작성할 수 있다!  

```javascript
let x = 1;
let y = 2;

let obj = {
  x: x,
  y: y
}

console.log(obj);     // {x: 1, y: 2}
```

<br />

→ 현재 x와 y변수를 obj의 프로퍼티 값으로 할당했다.
그런데 여기서 obj의 프로퍼티 key와 value가 똑같은 형태이기 때문에 좀 더 생략해서 표현할 수 있다.

```javascript
let x = 1;
let y = 2;

let obj = { x, y }

console.log(obj);     // {x: 1, y: 2}
```

<br />

### 계산된 프로퍼티 이름
- 프로퍼티 key를 표현식(값으로 평가되는 식)을 사용해 동적으로 생성할 수 있다.     
  이때 표현식을 `[]`로 묶어서 사용해야 한다.

```javascript
let abc = 'hello';
let i = 0;
let obj = {}

obj[`${abc} - ${++i}`] = i;
obj[`${abc} - ${++i}`] = i;
obj[`${abc} - ${++i}`] = i;

console.log(obj);     // {hello - 1: 1, hello - 2: 2, hello - 3: 3}
```

<br />

### 메서드 축약 표현
- 프로퍼티 값에 메서드를 정의할 때 function키워드를 생략해서 작성할 수 있다.

```javascript
const obj = {
  name: 'Lee',
  // 메서드 축약 표현
  sayHi() {
    console.log('Hi! ' + this.name);
  }
  /* es5
  sayHi: function() {
    console.log('Hi! ' + this.name);
  }*/
};

obj.sayHi(); // Hi! Lee
```